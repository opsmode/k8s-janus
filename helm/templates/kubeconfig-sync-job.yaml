{{- if and (not .Values.remote.enabled) .Values.kubeconfigSync.enabled }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: janus-kubeconfig-sync
  namespace: {{ .Values.janus.namespace }}
  labels:
    {{- include "janus.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: janus-kubeconfig-sync
  namespace: {{ .Values.kubeconfigSync.argocdNamespace }}
  labels:
    {{- include "janus.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]
    resourceNames: []
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: janus-kubeconfig-sync-argocd
  namespace: {{ .Values.kubeconfigSync.argocdNamespace }}
  labels:
    {{- include "janus.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: janus-kubeconfig-sync
subjects:
  - kind: ServiceAccount
    name: janus-kubeconfig-sync
    namespace: {{ .Values.janus.namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: janus-kubeconfig-sync
  namespace: {{ .Values.janus.namespace }}
  labels:
    {{- include "janus.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: janus-kubeconfig-sync
  namespace: {{ .Values.janus.namespace }}
  labels:
    {{- include "janus.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "-5"
    helm.sh/hook-delete-policy: before-hook-creation
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: janus-kubeconfig-sync
subjects:
  - kind: ServiceAccount
    name: janus-kubeconfig-sync
    namespace: {{ .Values.janus.namespace }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: janus-kubeconfig-sync
  namespace: {{ .Values.janus.namespace }}
  labels:
    {{- include "janus.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "0"
    helm.sh/hook-delete-policy: before-hook-creation
spec:
  ttlSecondsAfterFinished: 600
  template:
    metadata:
      labels:
        {{- include "janus.labels" . | nindent 8 }}
        app.kubernetes.io/component: kubeconfig-sync
    spec:
      serviceAccountName: janus-kubeconfig-sync
      restartPolicy: OnFailure
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: sync
          image: python:3.12-alpine
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop: [ALL]
          volumeMounts:
            - name: tmp
              mountPath: /tmp
          env:
            - name: ARGOCD_NAMESPACE
              value: {{ .Values.kubeconfigSync.argocdNamespace | quote }}
            - name: JANUS_NAMESPACE
              value: {{ .Values.janus.namespace | quote }}
            - name: TOKEN_DURATION
              value: {{ .Values.remote.tokenDuration | quote }}
            - name: SA_NAME
              value: {{ .Values.remote.serviceAccountName | quote }}
            - name: SA_NAMESPACE
              value: {{ .Values.remote.namespace | quote }}
            - name: CLUSTERS
              value: {{ range .Values.clusters }}{{ .name }},{{ end }}
          command:
            - python3
            - -c
            - |
              import os, json, base64, urllib.request, urllib.error, ssl, time

              APISERVER    = "https://kubernetes.default.svc"
              SA_TOKEN     = open("/var/run/secrets/kubernetes.io/serviceaccount/token").read()
              CA_CERT      = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
              ARGOCD_NS    = os.environ["ARGOCD_NAMESPACE"]
              JANUS_NS     = os.environ["JANUS_NAMESPACE"]
              TOKEN_DUR    = os.environ["TOKEN_DURATION"]
              SA_NAME      = os.environ["SA_NAME"]
              SA_NS        = os.environ["SA_NAMESPACE"]
              CLUSTERS_ENV = os.environ["CLUSTERS"]

              # Cluster names set from Helm values (comma-separated, may have trailing comma)
              target_clusters = [c for c in CLUSTERS_ENV.split(",") if c]
              # Skip the first cluster (central — no remote kubeconfig needed for self)
              remote_clusters = target_clusters[1:]

              def k8s_request(path, method="GET", body=None, token=SA_TOKEN,
                              server=APISERVER, ca=CA_CERT, insecure=False):
                  ctx = ssl.create_default_context()
                  if insecure:
                      ctx.check_hostname = False
                      ctx.verify_mode = ssl.CERT_NONE
                  elif ca != CA_CERT:
                      ctx.load_verify_locations(cadata=ca)
                  else:
                      ctx.load_verify_locations(CA_CERT)
                  headers = {"Authorization": f"Bearer {token}",
                             "Content-Type": "application/json",
                             "Accept": "application/json"}
                  data = json.dumps(body).encode() if body else None
                  req = urllib.request.Request(f"{server}{path}", data=data,
                                               headers=headers, method=method)
                  with urllib.request.urlopen(req, context=ctx, timeout=15) as r:
                      return json.loads(r.read())

              def get_argocd_cluster_secret(cluster_name):
                  """Read ArgoCD cluster Secret by label selector."""
                  path = (f"/api/v1/namespaces/{ARGOCD_NS}/secrets"
                          f"?labelSelector=argocd.argoproj.io/secret-type%3Dcluster")
                  secrets = k8s_request(path)
                  for s in secrets.get("items", []):
                      raw = {k: base64.b64decode(v).decode()
                             for k, v in s.get("data", {}).items()}
                      if raw.get("name") == cluster_name:
                          return raw
                  return None

              def issue_remote_token(server, ca_data, bearer_token, insecure,
                                     sa_name, sa_ns, duration):
                  """Call remote cluster API to issue a token for the janus-remote SA."""
                  # ca_data from ArgoCD secret is already base64-encoded PEM
                  ca_pem = base64.b64decode(ca_data).decode() if ca_data else None
                  body = {"spec": {"expirationSeconds": _duration_to_seconds(duration)}}
                  path = (f"/api/v1/namespaces/{sa_ns}"
                          f"/serviceaccounts/{sa_name}/token")
                  result = k8s_request(path, method="POST", body=body,
                                       token=bearer_token, server=server,
                                       ca=ca_pem, insecure=insecure)
                  return result["status"]["token"]

              def _duration_to_seconds(d):
                  """Convert e.g. '8760h' to seconds."""
                  if d.endswith("h"):
                      return int(d[:-1]) * 3600
                  if d.endswith("m"):
                      return int(d[:-1]) * 60
                  return int(d)

              def build_kubeconfig(cluster_name, server, ca_data, token, insecure):
                  ca_field = {}
                  if insecure:
                      ca_field = {"insecure-skip-tls-verify": True}
                  else:
                      ca_field = {"certificate-authority-data": ca_data}
                  return {
                      "apiVersion": "v1",
                      "kind": "Config",
                      "clusters": [{"name": cluster_name,
                                    "cluster": {"server": server, **ca_field}}],
                      "contexts": [{"name": cluster_name,
                                    "context": {"cluster": cluster_name,
                                                "user": SA_NAME}}],
                      "current-context": cluster_name,
                      "users": [{"name": SA_NAME,
                                 "user": {"token": token}}],
                  }

              def upsert_secret(secret_name, ns, kubeconfig_dict):
                  """Create or update the kubeconfig Secret on central cluster."""
                  kc_yaml = json.dumps(kubeconfig_dict)
                  kc_b64  = base64.b64encode(kc_yaml.encode()).decode()
                  body = {
                      "apiVersion": "v1",
                      "kind": "Secret",
                      "metadata": {
                          "name": secret_name,
                          "namespace": ns,
                          "labels": {"k8s-janus.opsmode.io/managed": "true"},
                      },
                      "type": "Opaque",
                      "data": {"kubeconfig": kc_b64},
                  }
                  path = f"/api/v1/namespaces/{ns}/secrets/{secret_name}"
                  try:
                      k8s_request(path, method="PUT", body=body)
                      print(f"  ✔ updated secret {secret_name}")
                  except urllib.error.HTTPError as e:
                      if e.code == 404:
                          k8s_request(f"/api/v1/namespaces/{ns}/secrets",
                                      method="POST", body=body)
                          print(f"  ✔ created secret {secret_name}")
                      else:
                          raise

              errors = []
              for cluster_name in remote_clusters:
                  print(f"\n→ {cluster_name}")
                  try:
                      argocd = get_argocd_cluster_secret(cluster_name)
                      if not argocd:
                          raise RuntimeError(f"ArgoCD cluster Secret not found for {cluster_name!r}")

                      config    = json.loads(argocd["config"])
                      server    = argocd["server"]
                      tls       = config.get("tlsClientConfig", {})
                      insecure  = tls.get("insecure", False)
                      ca_data   = tls.get("caData", "")
                      bearer    = config["bearerToken"]

                      token = issue_remote_token(server, ca_data, bearer, insecure,
                                                  SA_NAME, SA_NS, TOKEN_DUR)

                      secret_name = cluster_name + "-kubeconfig"
                      kc = build_kubeconfig(cluster_name, server, ca_data, token, insecure)
                      upsert_secret(secret_name, JANUS_NS, kc)
                  except Exception as ex:
                      print(f"  ✘ {cluster_name}: {ex}")
                      errors.append(cluster_name)

              if errors:
                  raise SystemExit(f"Failed for clusters: {errors}")
              print("\n✅ All kubeconfig Secrets synced")
      volumes:
        - name: tmp
          emptyDir: {}
{{- end }}
